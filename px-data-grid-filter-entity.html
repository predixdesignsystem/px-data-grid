<link rel="import" href="../polymer/polymer-element.html">
<link rel="import" href="../px-datetime-picker/px-datetime-picker.html">
<link rel="import" href="../px-slider/px-slider.html">
<link rel="import" href="../px-rangepicker/px-rangepicker.html">
<link rel="import" href="css/px-data-grid-filter-entity-styles.html">

<dom-module id="px-data-grid-filter-entity">
  <template>
    <style include="px-data-grid-filter-entity-styles"></style>

    <div class="labeled-text">
      <label for="column-dropdown">
        [[localize('Attribute')]]
      </label>
      <px-dropdown id="column-dropdown" items="[[_mappedColumns]]" selected="{{entity.columnId}}"></px-dropdown>
    </div>

    <template is="dom-if" if="{{_columnTypeIsString(entity.columnId)}}">
      <div class="labeled-text">
        <label for="condition-dropdown">
          [[localize('Condition')]]
        </label>
        <px-dropdown id="condition-dropdown" items="[[_regexPatterns]]" selected="{{entity.pattern}}"></px-dropdown>
      </div>

      <div class="labeled-text">
        <label for="value-input">
          [[localize('Value')]]
        </label>
        <input id="value-input" type="text" class="text-input" value="{{entity.query::input}}">
      </div>
    </template>

    <template is="dom-if" if="{{_columnTypeIsDate(entity.columnId)}}">
      <div class="labeled-text" extended>
        <label for="date-rangepicker">
          [[localize('Date Range')]]
        </label>
        <px-rangepicker
          id="date-rangepicker"
          hide-time
          hide-presets
          show-buttons
          date-format="YYYY/MM/DD"
          time-format="HH:mm:ss"
          time-zone="UTC"
          show-time-zone="abbreviatedText"
          from-moment="{{_dateFrom}}"
          to-moment="{{_dateTo}}">
        </px-rangepicker>
      </div>
    </template>

    <template is="dom-if" if="{{_columnTypeIsNumber(entity.columnId)}}">
      <template is="dom-if" if="{{!_showSlider(_minNumberBound, _maxNumberBound, columns.*)}}">
        <div class="labeled-text">
          <label for="range-input">
            [[localize('Condition')]]
          </label>
          <px-dropdown id="number-condition-dropdown" items="[[_numberConditions]]" selected="{{_numberCondition}}"></px-dropdown>
        </div>

        <div class="labeled-text">
          <label for="number-value-input">
            [[localize('Value')]]
          </label>
          <input id="number-value-input" type="text" class="text-input" value="{{_numberValue::input}}">
        </div>
      </template>

      <template is="dom-if" if="{{_showSlider(_minNumberBound, _maxNumberBound, columns.*)}}">
        <div class="labeled-text" extended>
          <label for="range-input">
            [[localize('Range')]]
          </label>
          <px-slider
            id="range-input"
            min="[[_minNumberBound]]"
            max="[[_maxNumberBound]]"
            value="{{entity.leftBound}}"
            end-value="{{entity.rightBound}}"
            step="1"
            is-range>
          </px-slider>
        </div>
      </template>
    </template>
  </template>
  <script>
    {
      /**
       * @memberof Predix
       * @extends Polymer.Element
       */
      class DataGridFilterEntityElement extends Polymer.Element {
        static get is() {
          return 'px-data-grid-filter-entity';
        }

        static get properties() {
          return {
            columns: Array,

            tableData: Array,

            entity: {
              type: Object
            },

            _mappedColumns: Array,

            _regexPatterns: {
              type: Array,
              value: [
                {
                  key: 'equals',
                  val: 'Equals'
                },
                {
                  key: 'contains',
                  val: 'Contains'
                },
                {
                  key: 'starts_with',
                  val: 'Starts With'
                },
                {
                  key: 'ends_with',
                  val: 'Ends With'
                },
                {
                  key: 'wildcard',
                  val: 'Wildcard'
                }
              ]
            },

            _numberConditions: {
              type: Array,
              value: [
                {
                  key: 'less_than',
                  val: 'Less Than'
                },
                {
                  key: 'greater_than',
                  val: 'Greater Than'
                }
              ]
            },

            _minNumberBound: Number,

            _maxNumberBound: Number,

            _dateFrom: {
              type: Object
            },

            _dateTo: {
              type: Object
            },

            _selectedColumnId: {
              type: String
            },

            localize: Function,

            _numberCondition: {
              type: String
            },

            _numberValue: {
              type: String
            }
          };
        }

        static get observers() {
          return [
            '_setMappedColumns(columns, columns.*)',
            '_filterActiveObservable(entity, entity.*)',
            '_momentDatesObserver(_dateFrom, _dateTo, _dateFrom.*, _dateTo.*)',
            '_entityDatesObserver(entity, entity.dateFrom, entity.dateTo)',
            '_selectedColumnChanged(_selectedColumnId)',
            '_localizeChanged(localize)',
            '_entityObserver(entity, entity.*)',
            '_columnNumberBoundsObserver(entity, entity.columnId, columns.*)',
            '_numberFilterChanged(_numberCondition, _numberValue)',
            '_initNumberFilter(entity, entity.leftBound, entity.rightBound)'
          ];
        }

        _localizeChanged(localize) {
          if (!localize) {
            return;
          }

          this._regexPatterns.forEach((pattern, index) => {
            this.set(`_regexPatterns.${index}.val`, localize(pattern.val));
          });

          this._numberConditions.forEach((condition, index) => {
            this.set(`_numberConditions.${index}.val`, localize(condition.val));
          });
        }

        _numberFilterChanged(condition, value) {
          if (!condition || value === undefined) {
            return;
          }

          const intValue = parseInt(value);
          if (condition === 'less_than' && this.entity.rightBound != intValue) {
            this.set('entity.rightBound', intValue);
            delete this.entity.leftBound;
            this.notifyPath('entity.leftBound');
          } else if (condition == 'greater_than' && this.entity.leftBound != intValue) {
            this.set('entity.leftBound', intValue);
            delete this.entity.rightBound;
            this.notifyPath('entity.rightBound');
          }
        }

        _initNumberFilter(entity) {
          if (entity.leftBound === undefined || entity.rightBound === undefined) {
            return;
          }

          if (entity.leftBound !== undefined) {
            this._numberCondition = 'greater_than';
            this.set('_numberValue', entity.leftBound);
          } else if (entity.rightBound !== undefined) {
            this._numberCondition = 'less_than';
            this.set('_numberValue', entity.rightBound);
          }
        }

        _columnNumberBoundsObserver(entity) {
          const column = this._getColumnById(entity.columnId);
          if (!this._columnTypeIsNumber(entity.columnId)) {
            return;
          }

          if (this.entity.leftBound === undefined) {
            this.set('entity.leftBound', column.minBound);
          }
          if (this.entity.rightBound === undefined) {
            this.set('entity.rightBound', column.maxBound);
          }

          this._minNumberBound = column.minBound;
          this._maxNumberBound = column.maxBound;
        }

        _entityObserver(entity) {
          if (!entity.columnId) {
            this.set('entity.columnId', '-any-');

            if (this._columnTypeIsString(this.entity.columnId)) {
              this.set('entity.pattern', this._regexPatterns[0].key);
            }
          }
        }

        _resolveColumnName(column) {
          return column.header ? column.header : (column.name ? column.name : column.path);
        }

        _setMappedColumns(columns, columnsSplices) {
          if (!columns && !columnsSplices) {
            return;
          }

          const optionList = [];

          optionList.push({
            key: '-any-',
            val: 'Any column'
          });

          columns.forEach((col) => {
            optionList.push({
              key: col.id,
              val: this._resolveColumnName(col)
            });
          });

          this.set('_mappedColumns', optionList);
        }

        _columnTypeIsString(columnId) {
          const column = this._getColumnById(columnId);

          return column && ['date', 'number'].indexOf(column.type) === -1;
        }

        _columnTypeIsDate(columnId) {
          const column = this._getColumnById(columnId);

          return column && column.type === 'date';
        }

        _columnTypeIsNumber(columnId) {
          const column = this._getColumnById(columnId);

          return column && column.type === 'number';
        }

        _getColumnById(columnId) {
          if (!this.columns) {
            return;
          }

          if (columnId === '-any-') {
            return {
              id: '-any-',
              type: 'string'
            };
          }

          return this.columns.filter((column) => column.id === columnId)[0];
        }

        _filterActiveObservable(entity) {
          if (entity.columnId) {
            if (this._columnTypeIsString(entity.columnId)) {
              this.set('entity.active', !!entity.pattern && !!entity.query && !!entity.columnId);
            } else if (this._columnTypeIsDate(entity.columnId)) {
              this.set('entity.active', !!entity.columnId && (!!entity.dateFrom || !!entity.dateTo));
            } else if (this._columnTypeIsNumber(entity.columnId)) {
              this.set('entity.active', !!entity.columnId && (!!entity.leftBound || !!entity.rightBound));
            }
          }
        }

        _momentDatesObserver(dateFrom, dateTo) {
          if (dateFrom && window.moment(this.entity.dateFrom).format() !== dateFrom.format()) {
            this.set('entity.dateFrom', dateFrom.format());
          }
          if (dateTo && window.moment(this.entity.dateTo).format() !== dateTo.format()) {
            this.set('entity.dateTo', dateTo.format());
          }
        }

        _entityDatesObserver(entity) {
          if (entity.dateFrom && (!this._dateFrom || window.moment(this.entity.dateFrom).format() !== this._dateFrom.format())) {
            this.set('_dateFrom', window.moment(this.entity.dateFrom));
          }
          if (entity.dateTo && (!this._dateTo || window.moment(this.entity.dateTo).format() !== this._dateTo.format())) {
            this.set('_dateTo', window.moment(this.entity.dateTo));
          }
        }

        _showSlider(minBound, maxBound) {
          return minBound !== undefined && maxBound !== undefined;
        }
      }

      customElements.define(DataGridFilterEntityElement.is, DataGridFilterEntityElement);

      /**
       * @namespace Predix
       */
      window.Predix = window.Predix || {};
      Predix.DataGridFilterEntityElement = DataGridFilterEntityElement;
    }
  </script>
</dom-module>
